<!doctype html>
<html>
    <head>
        <title>MicroGrad Visualization</title>
        <script src="viz-standalone.js"></script>
        <script src="engine.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css" />
    </head>
    <body>
        <div class="whole_area">
            <div class="code_area">
                <h1 style="color:#c65f63;">Write Code Here...</h1>
                <textarea id="code" rows="10" cols="32" resize="none"></textarea>
                <button class="draw" onclick="show()">Forward</button>
                <button class="grad" onclick="back()">Backward</button>
                <br></br>
                <h2 style="color:#f6e1b8;">Rules : </h2>
                <ul style="color:#f6e1b8;">
                    <li>like Python statement, ex : x = 1; </li>
                    <li>Must ends with ';'</li>
                    <li>Activation functions are 'relu','sigmoid','tanh'</li>
                </ul>
            </div>
            <div id="graph" class="graph"></div>
        <div>
        <script>
            // function to get nodes and edges
            function trace(root) {
                // builds a set of all nodes and edges in a graph
                let nodes = new Set();
                let edges = new Set();

                function build(v) {
                    if (!nodes.has(v)) {
                        nodes.add(v);
                        for (let child of v.prev) {
                            edges.add([child, v]);
                            build(child);
                        }
                    }
                }

                build(root);
                return [nodes, edges];
            }

            // variable to track the number of Value class
            var operations_code = [];

            // class to handle user string code
            class OperationParser {
                constructor(code) {
                    this.code = code;
                    this.variables = {};
                }

                // parse the code and remove extra spaces
                parse() {
                    const lines = this.code
                        .split(";")
                        .map((line) => line.trim())
                        .filter((line) => line);

                    lines.forEach((line) => {
                        let [left, right] = line
                            .split("=")
                            .map((part) => part.trim());
                        if (right.includes(".")) {
                            this.handleFunction(left, right);
                        } else {
                            this.handleAssignment(left, right);
                        }
                    });
                }

                // if the code consist activation function
                // next step using only limited number of activations
                handleFunction(left, right) {
                    const match = right.match(/(\w+)\.(\w+)\(([^)]*)\)/);
                    if (match) {
                        const [, variable, func] = match;
                        const value = this.getValue(variable.trim());
                        const result = value[func]();
                        result.op = func;
                        result.label = left;
                        this.variables[left] = result;
                        operations_code.push(result);
                    } else {
                        throw new Error(`Invalid function syntax: ${right}`);
                    }
                }

                // if there is airthmetic operations
                handleAssignment(left, right) {
                    const match = right.match(/(.+?)\s*([\+\-\*\/\^])\s*(.+)/);
                    if (match) {
                        const [, operand1, operator, operand2] = match;
                        const value1 = this.getValue(operand1.trim());
                        const value2 = this.getValue(operand2.trim());
                        const methodMap = {
                            "+": "add",
                            "-": "sub",
                            "*": "mult",
                            "/": "div",
                            "^": "pow",
                        };
                        const method = methodMap[operator];
                        const result = value1[method](value2);
                        result.label = left;
                        this.variables[left] = result;
                        operations_code.push(result);
                    } else {
                        const value = this.getValue(right);
                        value.label = left;
                        this.variables[left] = value;
                        operations_code.push(value);
                    }
                }

                // if the value not exist , create one
                getValue(operand) {
                    if (this.variables[operand]) {
                        return this.variables[operand];
                    } else if (!isNaN(parseFloat(operand))) {
                        return new Value(parseFloat(operand), operand);
                    } else {
                        throw new Error(`Undefined variable: ${operand}`);
                    }
                }
            }

            // after pressing the button
            function show() {
                operations_code = [];
                document.getElementById("graph").innerHTML = "";
                var text_code = document.getElementById("code").value;
                const parser = new OperationParser(text_code);
                parser.parse();

                console.log(operations_code);

                var [nodes, edges] = trace(operations_code.pop());

                const nods = Array.from(nodes);
                const edgs = Array.from(edges);

                var vv = "",
                    pp = "",
                    dd = "",
                    counter = 0;

                let dot = `digraph {
                        graph [rankdir=LR];
                        node [shape=record];
                    `;

                for (let n of nodes) {
                    let uid = `node${n.label}`;
                    // Create node with label and data
                    dot += `"${uid}" [label=" ${n.label} | data ${n.data.toFixed(4)} | grad ${n.grad.toFixed(4)} "];\n`;
                    if (n.op) {
                        // Create operation node
                        let opId = `op${n.label}${n.op}`;
                        dot += `"${opId}" [label="${n.op}", shape="circle"];\n`;
                        // Connect operation node to value node
                        dot += `"${opId}" -> "${uid}";\n`;
                    }
                }

                for (let [n1, n2] of edges) {
                    // Connect parent node to the operation node of the child node
                    let n1Id = `node${n1.label}`;
                    let n2OpId = `op${n2.label}${n2.op}`;
                    dot += `"${n1Id}" -> "${n2OpId}";\n`;
                }

                dot += `}`;

                Viz.instance().then(function (viz) {
                    var svg = viz.renderSVGElement(dot);

                    document.getElementById("graph").appendChild(svg);
                });
            }
        </script>
    </body>
</html>
