<!doctype html>
<html>
    <head>
        <title>Graphviz.js Example</title>
        <!-- <script src="vis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.css" rel="stylesheet" type="text/css"> -->
        <style>
            #graph {
                width: 800px;
                height: 600px;
                border: 1px solid rgb(152, 152, 152);
            }
            textarea {
                resize: none;
            }
            .graph {
                overflow: scroll;
            }
        </style>
    </head>
    <body>
        <div id="graph" class="graph"></div>
        <textarea id="code" rows="10" cols="60" resize="none"></textarea>
        <button onclick="show()">Show</button>
        <script src="viz-standalone.js"></script>
        <script src="engine.js"></script>
        <script>
            function trace(root) {
                // builds a set of all nodes and edges in a graph
                let nodes = new Set();
                let edges = new Set();

                function build(v) {
                    if (!nodes.has(v)) {
                        nodes.add(v);
                        for (let child of v.prev) {
                            edges.add([child, v]);
                            build(child);
                        }
                    }
                }

                build(root);
                return [nodes, edges];
            }

            a = new Value(5.0);
            a.label = "a";
            b = new Value(2.0);
            b.label = "b";

            c = a.mult(b);
            c.label = "c";

            d = c.sub(b);
            d.label = "d";

            var [nodes, edges] = trace(d);

            const nods = Array.from(nodes);
            const edgs = Array.from(edges);

            var vv = "",
                pp = "",
                dd = "",
                counter = 0;

            let dot = `digraph {
                    graph [rankdir=LR];
                    node [shape=record];
                `;

            for (let n of nodes) {
                let uid = `node${n.label}`;
                // Create node with label and data
                dot += `"${uid}" [label=" ${n.label} | data ${n.data.toFixed(4)} | grad ${n.grad.toFixed(4)} "];\n`;
                if (n.op) {
                    // Create operation node
                    let opId = `op${n.label}${n.op}`;
                    dot += `"${opId}" [label="${n.op}", shape="circle"];\n`;
                    // Connect operation node to value node
                    dot += `"${opId}" -> "${uid}";\n`;
                }
            }

            for (let [n1, n2] of edges) {
                // Connect parent node to the operation node of the child node
                let n1Id = `node${n1.label}`;
                let n2OpId = `op${n2.label}${n2.op}`;
                dot += `"${n1Id}" -> "${n2OpId}";\n`;
            }

            dot += `}`;

            Viz.instance().then(function (viz) {
                var svg = viz.renderSVGElement(dot);

                document.getElementById("graph").appendChild(svg);
            });

            var operations_code = [];

            class OperationParser {
                constructor(code) {
                    this.code = code;
                    this.variables = {};
                }

                parse() {
                    const lines = this.code
                        .split(";")
                        .map((line) => line.trim())
                        .filter((line) => line);

                    lines.forEach((line) => {
                        let [left, right] = line
                            .split("=")
                            .map((part) => part.trim());
                        if (right.includes(".")) {
                            this.handleFunction(left, right);
                        } else {
                            this.handleAssignment(left, right);
                        }
                    });
                }

                handleFunction(left, right) {
                    const match = right.match(/(\w+)\.(\w+)\(([^)]*)\)/);
                    if (match) {
                        const [, variable, func] = match;
                        const value = this.getValue(variable.trim());
                        const result = value[func]();
                        result.label = left;
                        this.variables[left] = result;
                        console.log("function are : ", result);
                    } else {
                        throw new Error(`Invalid function syntax: ${right}`);
                    }
                }

                handleAssignment(left, right) {
                    const match = right.match(/(.+?)\s*([\+\-\*\/\^])\s*(.+)/);
                    if (match) {
                        const [, operand1, operator, operand2] = match;
                        const value1 = this.getValue(operand1.trim());
                        const value2 = this.getValue(operand2.trim());
                        const methodMap = {
                            "+": "add",
                            "-": "sub",
                            "*": "mult",
                            "/": "div",
                            "^": "pow",
                        };
                        const method = methodMap[operator];
                        const result = value1[method](value2);
                        result.label = left;
                        this.variables[left] = result;
                        operations_code.push(result);
                    } else {
                        const value = this.getValue(right);
                        value.label = left;
                        this.variables[left] = value;
                        operations_code.push(value);
                    }
                }

                getValue(operand) {
                    if (this.variables[operand]) {
                        return this.variables[operand];
                    } else if (!isNaN(parseFloat(operand))) {
                        return new Value(parseFloat(operand), operand);
                    } else {
                        throw new Error(`Undefined variable: ${operand}`);
                    }
                }
            }

            function show() {
                var text_code = document.getElementById("code").value;
                const parser = new OperationParser(text_code);
                parser.parse();

                console.log(operations_code);
            }
        </script>
    </body>
</html>
